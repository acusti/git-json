var ancestor = require('./ancestor')
var walkback = require('./walkback')
var tools = require('./threewaymerge')
var diffpatch = require('./diffpatch')
var common = require('./common')
var merge = function(branchname,message) {
  this.push('merge:branchname'+branchname+':'+message+'\n')
  // fast forward
  var result = common.parseHEAD(this.HEAD)
  if (result.type == 'name') {
    key = this.refs[result.value]
  } else if (result.type == 'key') {
    // detached headless merge
    key = result.value
  }
  if (message === undefined) {
    message = 'Autogenerated merge message from ' + branchname + ' to ' + result.value
  }
  if (ancestor.call(this,branchname)) {
    var key;
    this.refs[branchname] = key
    // do not create commit for fastforward
    // do create a test that after FF merge, that a second merge attempt fails
  } else {
    var listA = walkback.call(this,branchname)
    if (result.type == 'name') {
      var listB = walkback.call(this,result.value)
    } else {
      var listB = walkback.call(this,result.value,true)
    }
    // now we look for most recent common ancestor
    var mostRecentCommonAncestor = ancestor.mostRecentCommonAncestor(listA,listB)
    // now construct the three trees, a, b, ancestor
    // then 
    // first generate two diff sets (ancestor->a), (ancestor->b)
    // reduce two changes that are identical to one change (REDUCER)
    // identify the conflicts from the reduced set (CONFLICTS)
    // create a final clean set  (REMOVER)
    // if no conflicts, apply clean set, if conflicts ... 

    var a_commit = this.commits[listA[0]]
    var b_commit = this.commits[listB[0]] 
    var ancestor_commit = this.commits[mostRecentCommonAncestor]

    var a_tree = this.trees[a_commit.tree]    
    var b_tree = this.trees[b_commit.tree]    
    var ancestor_tree = this.trees[ancestor_commit.tree]

    var a_data = tools.buildTree(a_tree,this.blobs)
    var b_data = tools.buildTree(b_tree,this.blobs)
    var ancestor_data = tools.buildTree(ancestor_tree,this.blobs)
    var results = tools.threewaymerge(a_data,b_data,ancestor_data)
    // now we want to perform to apply patches to b then create a commit simply by moving our patched result to staging then running commit
    if ((results.conflicts.length === 0) && (results.reduced.length == results.finalset.length)) {
      this.staging =  diffpatch.applyChanges(b_data,results.finalset)
      message += ' (Non FF, conflictless merge)'
      this.commit(message)
    }
    return results
  }
}
module.exports = exports = merge
